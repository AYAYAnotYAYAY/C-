#include <stdio.h>
#include <stdlib.h>
/**************************************************************************
AYAYA的第一个C语言程序，根据教程学习基本写法，用法，以后留作纪念嘻嘻嘻。
***************************************************************************/
int main()
{
        printf("Boy next door!\n");

//玩游戏玩的开心吗boy
        printf("Do you like Van 游戏？\t OK,let go");
        //搞事小能手啊？
        printf("\n");
        printf("kou  bi 想上秋名山？");
        printf("\n 你是跑不过我的AE86的\n");

//  \n表示换行符  \t表示空格

        int van=5000;
        //变量van 等于5000  这里的5000是整数形
        printf("Van是%d\n",van);
        //引用变量van
        //%d表示转换说明符这里的%表示转换说明符的开头，%d表示van输出为一个十进制的数字
        //转换说明符确定变量在屏幕上的显示方式
        int Chang=1472583524;
     //声明一个整数64位整数类型的变量Chang
     int MMP;
     MMP=88888;
     //声明一个整数型变量MMP  MMP=88888 先声明后初始化
    int ooo=MMP;
    //声明ooo等于MMP理论MMP是多少ooo就应该是多少
        printf("MMP的数值是%d\n",MMP);
        printf("ooo的数值是%d\n",ooo);
        printf("第一个Chang的值%d\n第二个ooo的值%d\n",Chang,ooo);
        //上一句代码有2个%d。第一个%d代表后面,后面的第一个给予值Chang。第二个%d代表后面第二个给予值MMP
                float c,k,g;//声明3个单精度浮点变量分别是c，k，g且未给出初始值
                float s;//声明一个单精度浮点变量为s且此时的s并没有给出值，需要初始化
                c=99.8f;//给予ckg分别的值
                k=8.8f;//因为float类型的值，赋值时需要在值后面加一个f。float的值是7位数，即小数点前后相加不超过7位
                g=9.7f;
                s=c*k*g;//声明s的值等于c乘以k乘以g。此时ckg有值所以s等于多少被声明并计算了。
                printf("S的值等于%f\n",s);//显示S的值这里的%f是float的占位符，不再是%d而是%f。此时生成的数字会默认显示小数点后6位
                printf("S的值等于%.3f\n",s);//占位符%.3f加了个.3现在只显示小数点后3位数
                printf("S的值等于%.2f\n",s);//占位符%.2f加了个.3现在只显示小数点后2位数
                double autumn;//声明一个双精度浮点变量autumn
                autumn=1895567.223856479;//初始化值
                printf("双精度小数autumn值为：%lf\n",autumn);//double类型占位符为%lf
                printf("双精度小数autumn值为：%.2lf\n",autumn);//同理单精度占位符前加.数字控制小数位数
                char AYAYA;//char类型的变量其实是以int的形式表示的
                AYAYA='E';
                printf("char类型变量AYAYA的值为%c\n",AYAYA);
                printf("char大写转小写%c",AYAYA+32);//大写字母的ASCII码加32就是小写字母的ASCII码。空格的ASCII码就是32.
                int A,B,C;
                A=10;
                printf("\nA的值为%d",A);
                B=A++;
                printf("\n输出此时的A：%d",A);
                C=++A;
                printf("\nB的值为%d\nC的值为%d\n经过运算后的A此时等于%d\n",B,C,A);
                /*上面打印的B的值为10，C的值为12，而且A在经过b和C的赋值运算后。A自身的值也等于了12.********************************
                B=A++这条代码的B等于10，而运算完这条代码后A却等于了11. 所以，这条代码的逻辑是首先将A的值赋与B。代码结束A再进行自加计算。
                所以B的值是在A自加运算之前的值，为10.
                C=++A的代码中C等于12，A也等于12. 因为在上一条代码中A已经自加过一次所以，A等于11.
                在这条代码中++A首先被运行。所以A自加一次等于12.再赋值给C。故现在的C得到的值为12.
                ********************************************************************************************************************/
                double xZ,xY,xH;
                xZ=3.1415926;
                xY=6.99877;
                xH=125.8874523;
                printf("\n因暂时未学习判断语句返回值0和非0代表错误与正确\nxZ是否比xY大？\t答案：%d\nxY是否比xH大？\t答案:%d\nxZ是否比xH大？\t答案：%d",xZ > xY,xY > xH,xZ > xH);
                //很简单的关系运算符> < >= <= == !=大与小与  大于等于  小于等于  等于  不等于。
                //注意：关系运算符的返回值是一个int值0或非0.表示真与假。与被比较的2个值的类型无关。所以引用返回值的时候是int型。
                //比如上面声明的变量xZ，xY，xH都是double类型。但在比较后引用结果的时候，是使用%d而不是%lf。xZ >  xY已经是一个子程序了。返回值是int型
                printf("\nsizeof代码区一个数据所占字节大小。比如int型占%d字节",sizeof(int));
                printf("\nsizeof代码区一个数据所占字节大小。比如double型占%d字节",sizeof(3.1415926));
                /*关系运算符：　>  <  >=  <=  ==  !=
                  基本运算符：  +  -  *  /   %（取模，也就是取余数的意思）*/
                  int tt,bb,jj;
                  tt=1;
                  bb=2;
                  jj=3;
                  //演示逻辑运算符：&&与   ||或  ！非
                  printf("\n演示逻辑运算符与的用法：\ntt<bb与bb<jj的返回值是%d\t ",tt < bb && bb < jj);
                  printf("\ntt<bb与bb=jj的返回值是%d\t ",tt < bb && bb == jj);//&&的用法是同时满足前后两个条件则返回真，否则返回假
                  //同理或，非。自行理解。||满足左右其中一个就返回真。否则返回假。
                  //非！
                 int sk=10;
                 int sk2=sk++ >11 && --sk <20;//短路运算
                 printf("\nsk的值为：%d",sk);
                 printf("\nsk2的值为：%d",sk2);
                 //首先sk2=sk++ >11 && --sk<20这是一个逻辑运算的代码，不同于之前的B=A++此时的sk是被拉入一个逻辑运算里了。所以并不会被优先赋值给sk2.
                 //不管输入的sk为几。逻辑运算的结果最后只能为0或非0.所以sk2的值是0或非0.
                 //究竟是0还是非0就要看sk的值是否满足条件。
                 //然后sk++ >11 && --sk<20可以看作一整个代码。首先&&与代码需要两边同时满足为真则为真。
                 //先看左边这里sk++是后置自加运算，只有整条代码运算完毕后才自加一次。
                 //所以此时sk++ >11的比较是10>11肯定是假。所以。不满足与的条件了。
                 //所以第一条代码已经返回值为假了。与后面的条件则不会再执行。直接返回0
                 //然后sk2被赋值0.此条代码结束。sk自加1.sk等于11
                 sk=10;//再次初始化sk
                 sk2=sk++ >11 || --sk <20;
                 //这里sk2的值为1了。sk依然等于10
                 //这里逻辑运算符使用的是或。首先sk++要在代码结束后sk才会自加1.现在比较的是10>11返回为假。
                 //使用了或，第一个条件满足失败，则开始验证第二个条件。第二个条件--sk<20首先sk先自减1.然后比较10-1<20即9<20
                 //9<20返回真，逻辑与算或2个条件满足一个就返回真。所以sk2的值就等于1.本条代码结束。sk自加1
                 //此时sk等于10
                 printf("\nsk的值为：%d",sk);
                 printf("\nsk2的值为：%d",sk2);
                 printf("\n%d",!((18+45%3*5)>16));
                 //返回值为0
                 //首先！（）为非。所以得出来的真假要取相反的。再看（18+45%3*5）>16这是在做逻辑运算。比较括号里的数和16谁大
                 //先算乘除后算加减。45%3取摸。45%3的余数是0，所以得0.0*5=0计算加减18+0=18
                 //18>16返回真
                 //但是有！（）所以此时！（真）是要提供反值的。所以返回的是假。
                 //所以打印的%d为0
                 //运算符优先级，！ ~ ++ -- sizeof优先级最高
                 //赋值运算符优先级最低=  +=  -=这些。
                 /*1.= 赋值运算符  变量=表达式   如：a=3；将a的值赋为3
                    2./= 除后赋值    变量/=表达式  如：a/=3;即a=a/3
                    3.*= 乘后赋值    变量*=表达式  如：a*=3;即a=a*3
                    4.%= 取模后赋值  变量%=表达式  如：a%=3;即a=a%3
                    5.+= 加后赋值    变量+=表达式 如：a+=3;即a=a+3
                    6.-= 减后赋值 变量-=表达式 如：a-=3;即a=a-3
                    7.<<=     左移后赋值 变量<<=表达式 左移就是将《左边的数的二进制各位全部左移若干位，《右边的数指定移动位数，高位丢弃，低位补0，
                    移几位就相当于乘以2的几次方
                    8.>>= 右移后赋值 变量>>=表达式   右移运算符是用来将一个数的各二进制位右移若干位，移动的位数由右操作数指定（右操作数必须是非负值），
                    移到右端的低位被舍弃，对于无符号数，高位补0。对于有符号数，某些机器将对左边空出的部分用符号位填补（即“算术移位”），而另一些机器则对左边空出的部分
                    用0填补（即“逻辑移位”）。注意：对无符号数,右移时左边高位移入0；对于有符号的值,如果原来符号位为0(该数为正),则左边也是移入0。如果符号位原来为1(即负数),
                    则左边移入0还是1,要取决于所用的计算机系统。有的系统移入0,有的
                    系统移入1。移入0的称为“逻辑移位”,即简单移位；移入1的称为“算术移位”。
                    9.&= 按位与后赋值 变量&=表达式    按位与是指：参加运算的两个数据，按二进制位进行“与”运算。如果两个相应的二进制位都为1，则该位的结果值为1；否则为0。
                    这里的1可以理解为逻辑中的true,0可以理解为逻辑中的false。按位与其实与逻辑上“与”的运算规则一致。逻辑上的“与”，要求运算数全真，结果才为真。
                    若，A=true,B=true,则A∩B=true
                    10. ^= 按位异或后赋值  变量^=表达式  参与运算的两个量按照对应的位进行异或运算，且
                    0^0→0,  0^1→1,  1^0→1,  1^1→0
                    此外，一个数与0异或仍保持不变，即a^0=a
                    一个数与自己异或结果为0，即a^a=0
                    11.|= 按位或后赋值 变量|=表达式  参与运算的两个量按照对应位进行或运算，且
                    0|0→0,  0|1→1,  1|0→1,  1|1→1*/
                    //可以通过（）控制表达式的运算顺序，（）优先级最高。
                    //从右向左结合性的只有赋值运算符,三目运算符和单目运算符
                    //算数运算符>关系运算符>逻辑运算符







                return 0;
}
